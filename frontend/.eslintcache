[{"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\index.js":"1","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\reportWebVitals.js":"2","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\App.js":"3","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\store.js":"4","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\AuthRoute.js":"5","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\darkTheme.js":"6","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\Spinner.js":"7","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\UploadAvatar.js":"8","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\lightTheme.js":"9","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\ToggleTheme.js":"10","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\Login.js":"11","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\Mui.js":"12","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\chatMessageReducer.js":"13","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\userReducer.js":"14","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\themeReducer.js":"15","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\socketReducer.js":"16","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\types.js":"17","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatFriendsList.js":"18","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatMessageArea.js":"19","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatUserData.js":"20","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatHeader.js":"21","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatInput.js":"22","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\actions\\authActions.js":"23","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\actions\\chatMessageActions.js":"24","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\actions\\userActions.js":"25","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\config\\axios.js":"26","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\GroupChat.js":"27","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\helperFunctions.js":"28","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\CreateGroupModal.js":"29","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\StyledBadge.js":"30","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\joinChatRoomModal.js":"31"},{"size":637,"mtime":1613245639965,"results":"32","hashOfConfig":"33"},{"size":362,"mtime":499162500000,"results":"34","hashOfConfig":"33"},{"size":1584,"mtime":1620056525707,"results":"35","hashOfConfig":"33"},{"size":794,"mtime":1617365567971,"results":"36","hashOfConfig":"33"},{"size":3668,"mtime":1620056525737,"results":"37","hashOfConfig":"33"},{"size":1984,"mtime":1620056525742,"results":"38","hashOfConfig":"33"},{"size":158,"mtime":1613641508407,"results":"39","hashOfConfig":"33"},{"size":2893,"mtime":1616013667415,"results":"40","hashOfConfig":"33"},{"size":1847,"mtime":1620056525749,"results":"41","hashOfConfig":"33"},{"size":1333,"mtime":1615995430226,"results":"42","hashOfConfig":"33"},{"size":4486,"mtime":1620990015777,"results":"43","hashOfConfig":"33"},{"size":3083,"mtime":1620056525721,"results":"44","hashOfConfig":"33"},{"size":9883,"mtime":1620473834575,"results":"45","hashOfConfig":"33"},{"size":2882,"mtime":1620989896729,"results":"46","hashOfConfig":"33"},{"size":445,"mtime":1615995430148,"results":"47","hashOfConfig":"33"},{"size":413,"mtime":1614944673940,"results":"48","hashOfConfig":"33"},{"size":2333,"mtime":1620402908647,"results":"49","hashOfConfig":"33"},{"size":19634,"mtime":1620477575308,"results":"50","hashOfConfig":"33"},{"size":10517,"mtime":1620476786462,"results":"51","hashOfConfig":"33"},{"size":3079,"mtime":1620056525717,"results":"52","hashOfConfig":"33"},{"size":4948,"mtime":1620402908639,"results":"53","hashOfConfig":"33"},{"size":1995,"mtime":1620056525713,"results":"54","hashOfConfig":"33"},{"size":775,"mtime":1620056525724,"results":"55","hashOfConfig":"33"},{"size":10047,"mtime":1620473841214,"results":"56","hashOfConfig":"33"},{"size":1536,"mtime":1620989976042,"results":"57","hashOfConfig":"33"},{"size":207,"mtime":1614944673940,"results":"58","hashOfConfig":"33"},{"size":3508,"mtime":1620477391386,"results":"59","hashOfConfig":"33"},{"size":416,"mtime":1620056525745,"results":"60","hashOfConfig":"33"},{"size":9529,"mtime":1620989907703,"results":"61","hashOfConfig":"33"},{"size":751,"mtime":1620056525740,"results":"62","hashOfConfig":"33"},{"size":11623,"mtime":1620207638993,"results":"63","hashOfConfig":"33"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},"1r1jcwq",{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75","usedDeprecatedRules":"66"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"66"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"66"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104","usedDeprecatedRules":"66"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"66"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"116","messages":"117","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"118","usedDeprecatedRules":"66"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"123","messages":"124","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"125","usedDeprecatedRules":"66"},{"filePath":"126","messages":"127","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"66"},{"filePath":"129","messages":"130","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"131","messages":"132","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"135","usedDeprecatedRules":"66"},"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\index.js",[],["136","137"],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\reportWebVitals.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\App.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\store.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\AuthRoute.js",["138"],"// Redux\r\nimport { connect, useDispatch } from 'react-redux';\r\n\r\n// Actions\r\nimport { getCurrentLoggedInUser } from '../redux/actions/authActions';\r\nimport { updateConnectedUserList } from '../redux/actions/userActions';\r\nimport { getAllUserChatRooms } from '../redux/actions/chatMessageActions';\r\n\r\n// React Router DOM\r\nimport { Redirect, Route } from 'react-router-dom';\r\n\r\n// Components\r\nimport Spinner from './Spinner';\r\n\r\nimport { useEffect } from 'react';\r\n\r\n// Socket io\r\nimport {\r\n  USER_CONNECTED,\r\n  USER_DISCONNECTED,\r\n  SEND_USER_SOCKET,\r\n  SEND_BACK_USER_SOCKET,\r\n  UPDATE_USERS_WITH_SOCKETS,\r\n} from '../redux/types';\r\n\r\n// When we specify an Authroute:\r\n//  - getCurrentLoggedInUser checks if the user is logged in. (componentDidMount)\r\n//  - When the user is loading, show a spinner\r\n//  - When the user is loaded, socket.emit USER_CONNECTED to the server.\r\n//  - When props.user._id === true, it means the user is logged in. Render the passed in component (props.component)\r\n//  - When props.user._id === false, it means the user is not logged in. redirect to /login\r\n\r\nconst AuthRoute = props => {\r\n  const {\r\n    getCurrentLoggedInUser,\r\n    getAllUserChatRooms,\r\n    updateConnectedUserList,\r\n    socket,\r\n    user,\r\n  } = props;\r\n\r\n  const dispatch = useDispatch();\r\n\r\n  // componentDidMount\r\n  useEffect(() => {\r\n    getCurrentLoggedInUser();\r\n  }, [getCurrentLoggedInUser]);\r\n\r\n  // Connected user list\r\n  useEffect(() => {\r\n    // When the user is set, emit the user to the backend, where the user is added to the connected userList.\r\n    if (user._id) {\r\n      // Get all the chatRooms the user is a member of when the user is set\r\n      getAllUserChatRooms(`members=${user._id}`);\r\n\r\n      socket.emit(USER_CONNECTED, user);\r\n      console.log(socket.id);\r\n      // socket.emit(SEND_USER_SOCKET, { user: { ...user, socketId: socket.id } });\r\n      console.log('user is set');\r\n\r\n      // Receive the connected users userList from the backend\r\n      socket.on(USER_CONNECTED, userListFromBackend => {\r\n        console.log('USER CONNECTED 🧙‍♂️');\r\n        console.log(userListFromBackend);\r\n        // TODO dispatch action to update props.connectedUsers\r\n        updateConnectedUserList(userListFromBackend);\r\n        socket.emit(SEND_USER_SOCKET, { user: { ...user, socketId: socket.id } });\r\n      });\r\n\r\n      // Receive the updated connected users userList from the backend\r\n      socket.on(USER_DISCONNECTED, userListFromBackend => {\r\n        console.log(userListFromBackend);\r\n        // TODO dispatch action to update props.connectedUsers\r\n        updateConnectedUserList(userListFromBackend);\r\n      });\r\n\r\n      if (socket._callbacks !== undefined && socket._callbacks['$SEND_BACK_USER_SOCKET']) {\r\n        socket._callbacks['$SEND_BACK_USER_SOCKET'].length = 0;\r\n      }\r\n\r\n      socket.on(SEND_BACK_USER_SOCKET, userAndSocket => {\r\n        console.log(socket);\r\n        console.log(userAndSocket);\r\n        dispatch({ type: UPDATE_USERS_WITH_SOCKETS, payload: userAndSocket });\r\n      });\r\n    }\r\n  }, [updateConnectedUserList, socket, user, getAllUserChatRooms]);\r\n\r\n  // Render\r\n  return (\r\n    <Route\r\n      render={() =>\r\n        props.loading ? (\r\n          <Spinner />\r\n        ) : props.user._id ? (\r\n          <props.component />\r\n        ) : (\r\n          <Redirect to='/login' />\r\n        )\r\n      }\r\n    />\r\n  );\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    socket: state.socket.socket,\r\n    user: state.user.user,\r\n    loading: state.user.loading,\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, {\r\n  getCurrentLoggedInUser,\r\n  updateConnectedUserList,\r\n  getAllUserChatRooms,\r\n})(AuthRoute);\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\darkTheme.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\Spinner.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\UploadAvatar.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\lightTheme.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\ToggleTheme.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\Login.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\Mui.js",["139"],"import { useState, useEffect } from 'react';\r\n\r\n// Redux\r\nimport { connect } from 'react-redux';\r\nimport { getAllChatMessages } from '../redux/actions/chatMessageActions';\r\n\r\n// Components\r\nimport ChatUserData from './ChatUserData';\r\nimport ChatHeader from './ChatHeader';\r\nimport ChatFriendList from './ChatFriendsList';\r\nimport ChatMessageArea from './ChatMessageArea';\r\nimport ChatInput from './ChatInput';\r\n\r\n// MUI\r\nimport Grid from '@material-ui/core/Grid';\r\nimport { makeStyles, useTheme } from '@material-ui/core/styles';\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n  userData: {\r\n    backgroundColor: theme.palette.primary.main,\r\n    borderRight: '1px solid lightgrey',\r\n    borderBottom: '1px solid lightgrey',\r\n  },\r\n  header: {\r\n    backgroundColor: theme.palette.primary.main,\r\n    flex: 1,\r\n    borderBottom: '1px solid lightgrey',\r\n  },\r\n  list: {\r\n    minHeight: '85vh',\r\n    height: '821px',\r\n    overflowX: 'hidden',\r\n    overflowY: 'auto',\r\n    borderRight: '1px solid lightgrey',\r\n    borderBottom: '1px solid lightgrey',\r\n  },\r\n  chatMessages: {\r\n    height: '64vh',\r\n    overflowY: 'auto',\r\n    borderBottom: '1px solid lightgrey',\r\n  },\r\n  input: {\r\n    paddingTop: 60,\r\n    padding: 60,\r\n    borderBottom: '1px solid lightgrey',\r\n  },\r\n}));\r\n\r\nconst Mui = props => {\r\n  console.log(props);\r\n  const theme = useTheme();\r\n  const classes = useStyles(theme);\r\n  const [skip, setSkip] = useState(props.chatMessages.length);\r\n\r\n  useEffect(() => {\r\n    setSkip(props.chatMessages.length);\r\n    console.log(props.chatMessages.length);\r\n    console.log(skip);\r\n  }, [props.activeChatRoom, props.chatMessages.length]);\r\n\r\n  const handleScroll = e => {\r\n    let { scrollTop } = e.target;\r\n\r\n    // ALs de result meer dan 0 is\r\n    if (scrollTop === 0 && props.chatMessages.length >= 10) {\r\n      console.log('setSkip');\r\n      console.log(skip);\r\n      console.log(props.chatMessages.length);\r\n      setSkip(props.chatMessages.length);\r\n      props.getAllChatMessages(props.activeChatRoom._id, skip);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Grid container>\r\n        {/* User Data */}\r\n        <Grid item xs={3} className={classes.userData}>\r\n          <ChatUserData />\r\n        </Grid>\r\n        <Grid item xs={9} className={classes.header}>\r\n          <ChatHeader />\r\n        </Grid>\r\n      </Grid>\r\n\r\n      {/* Friends list */}\r\n      <Grid item container xs={12}>\r\n        <Grid item xs={3} className={classes.list}>\r\n          <ChatFriendList />\r\n        </Grid>\r\n\r\n        {/* Chat Messages */}\r\n        <Grid item container xs={9} md={9}>\r\n          <Grid item xs={12} className={classes.chatMessages} onScroll={handleScroll}>\r\n            <ChatMessageArea />\r\n          </Grid>\r\n          <Grid item xs={12} className={classes.input}>\r\n            <ChatInput />\r\n          </Grid>\r\n        </Grid>\r\n      </Grid>\r\n    </>\r\n  );\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    activeChatRoom: state.chat.activeChatRoom,\r\n    chatMessages: state.chat.chatMessages,\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, { getAllChatMessages })(Mui);\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\chatMessageReducer.js",["140","141"],"import {\r\n  GET_ALL_CHAT_MESSAGES,\r\n  CREATE_CHAT_MESSAGE,\r\n  SET_LAST_CHAT_MESSAGE,\r\n  SET_UNREAD_MESSAGES,\r\n  MARK_MESSAGES_READ,\r\n  DELETE_CHAT_MESSAGE,\r\n  SET_ACTIVE_CHATROOM,\r\n  SET_USER_CHATROOMS,\r\n  CREATE_CHAT_ROOM,\r\n  LEAVE_CHATROOM,\r\n  LEFT_CHATROOM,\r\n  TOGGLE_CHAT,\r\n  TOGGLE_CONTACTS,\r\n  SET_NO_ACTIVE_CHATROOM,\r\n  ADDED_USERS_TO_CHATROOM,\r\n} from '../types';\r\n\r\nconst initialState = {\r\n  chatMessages: [],\r\n  chatRooms: [],\r\n  lastMessages: [],\r\n  activeChatRoom: [],\r\n  unreadMessages: [],\r\n  totalUnread: 0,\r\n  toggleFriendList: 'contacts',\r\n  // loading: true,\r\n};\r\nexport default function chatMessageReducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case GET_ALL_CHAT_MESSAGES:\r\n      return {\r\n        ...state,\r\n        chatMessages: [...action.payload.reverse(), ...state.chatMessages],\r\n      };\r\n\r\n    case CREATE_CHAT_MESSAGE:\r\n      let chatMessages = [...state.chatMessages];\r\n      console.log(state.chatMessages.length);\r\n      // When a user has scrolled up to get older messages, shrink the array down to 10 again, so it scrolls into the created message\r\n      if (chatMessages.length > 10) {\r\n        chatMessages = chatMessages.slice(state.chatMessages.length - 10);\r\n      }\r\n      console.log(chatMessages);\r\n      return {\r\n        ...state,\r\n        // lastMessages: newLastMessages,\r\n        chatMessages:\r\n          state.chatMessages.length > 9\r\n            ? [...chatMessages, action.payload].slice(1) // keep the max size of chatMessages at 10\r\n            : [...state.chatMessages, action.payload],\r\n      };\r\n\r\n    case SET_LAST_CHAT_MESSAGE: {\r\n      // only return lastMessages where the message is not undefined\r\n      let newLastMessages = [...state.lastMessages].filter(message => message && message);\r\n      // console.log(newLastMessages);\r\n\r\n      // Resort the friendslist on last created message\r\n      newLastMessages.map((message, i) => {\r\n        if (message.chatRoomId === action.payload.chatRoomId) {\r\n          return (newLastMessages[i] = { ...action.payload });\r\n        }\r\n        return null;\r\n      });\r\n\r\n      return {\r\n        ...state,\r\n        lastMessages: newLastMessages,\r\n      };\r\n    }\r\n    case DELETE_CHAT_MESSAGE: {\r\n      // console.log('reducer', action.payload); // payload here ==- screamId\r\n      // let filteredScreams = state.screams.filter(scream => scream.screamId !== action.payload);\r\n      // return {\r\n      //   ...state,\r\n      //   screams: filteredScreams,\r\n      // };\r\n\r\n      // findIndex stops when the index is found, filter does not. findindex should be faster here\r\n\r\n      let index = state.chatMessages.findIndex(message => message._id === action.payload);\r\n      let filteredChatMessages = [...state.chatMessages];\r\n      filteredChatMessages.splice(index, 1);\r\n\r\n      console.log(filteredChatMessages);\r\n      console.log(state);\r\n      return {\r\n        ...state,\r\n        chatMessages: filteredChatMessages,\r\n      };\r\n    }\r\n    case SET_USER_CHATROOMS: // Only chatRooms that have messages are rendered\r\n      let lastMessages = action.payload.map(room => room.chatMessages[0]);\r\n      // console.log(action.payload);\r\n\r\n      let sortedChatRooms = [...action.payload];\r\n\r\n      // only return the chatrooms where there are chatmessages if there are 2 room members, also return groupchats // not sure if this works correctly\r\n      sortedChatRooms = sortedChatRooms.filter(room => {\r\n        if (room.chatMessages.length > 0 && room.members.length >= 1) {\r\n          return room;\r\n        }\r\n        return null;\r\n      });\r\n\r\n      sortedChatRooms.sort((a, b) => {\r\n        if (a.chatMessages[0] && b.chatMessages[0]) {\r\n          return new Date(b.chatMessages[0].createdAt) - new Date(a.chatMessages[0].createdAt);\r\n        } else {\r\n          console.log('NO CHATMESSAGES TO SORT');\r\n          return null;\r\n        }\r\n      });\r\n\r\n      console.log(state);\r\n      console.log(sortedChatRooms);\r\n\r\n      // Mark chatmessage as read if the user has the chatroom open (without having to click the chatroom )\r\n      sortedChatRooms.map(room => {\r\n        if (room._id === state.activeChatRoom._id) {\r\n          console.log('mark messages read');\r\n          room.chatMessages.map(message => {\r\n            if (message.read === false) {\r\n              // console.log(message);\r\n              // message.read = true;\r\n            }\r\n            return null;\r\n          });\r\n        }\r\n        return null;\r\n      });\r\n\r\n      return {\r\n        ...state,\r\n        // loading: false,\r\n        lastMessages: lastMessages,\r\n        // chatRooms: action.payload,\r\n        chatRooms: sortedChatRooms, // initial sort on page load/refresh. rerender sorting happens in SET_LAST_CHAT_MESSAGE\r\n      };\r\n    case SET_ACTIVE_CHATROOM:\r\n      // console.log(action.payload);\r\n      // console.log(state);\r\n\r\n      // set chatroom message as read\r\n      let rooms = state.chatRooms?.filter(room => {\r\n        if (action.payload._id === room._id) {\r\n          room.chatMessages?.filter(message => {\r\n            if (message.read === false) {\r\n              // message.read = true;\r\n            }\r\n            return null;\r\n          });\r\n        }\r\n        return null;\r\n      });\r\n      console.log(rooms);\r\n\r\n      return {\r\n        ...state,\r\n        activeChatRoom: action.payload,\r\n        chatMessages: action.payload.chatMessages.reverse(),\r\n      };\r\n    case CREATE_CHAT_ROOM: {\r\n      const newChatRooms = [...state.chatRooms];\r\n      console.log(newChatRooms);\r\n      console.log(action.payload);\r\n\r\n      return {\r\n        ...state,\r\n        chatRooms: [...newChatRooms, action.payload],\r\n      };\r\n    }\r\n    case LEAVE_CHATROOM: {\r\n      const newChatRooms = [...state.chatRooms];\r\n      console.log(newChatRooms);\r\n      console.log(action.payload);\r\n      console.log(action.payload.data._id);\r\n      let roomId = action.payload.data._id;\r\n\r\n      const roomIndex = newChatRooms.findIndex(room => {\r\n        console.log(room);\r\n        return room.id === roomId;\r\n      });\r\n\r\n      console.log(roomIndex);\r\n\r\n      newChatRooms.splice(roomIndex, 1);\r\n      console.log(newChatRooms);\r\n\r\n      return {\r\n        ...state,\r\n        chatRooms: newChatRooms,\r\n      };\r\n    }\r\n    case LEFT_CHATROOM: {\r\n      const newChatRooms = [...state.chatRooms];\r\n      const newActiveChatRoom = { ...state.activeChatRoom };\r\n\r\n      console.log(newActiveChatRoom);\r\n\r\n      // console.log(action.payload);\r\n      // console.log(newChatRooms);\r\n\r\n      const { roomId, leftUserId, leftRoom } = action.payload;\r\n\r\n      console.log(leftRoom);\r\n\r\n      newChatRooms.map(room => {\r\n        if (room._id === roomId) {\r\n          console.log(room);\r\n          const leftUserIndex = room.members.findIndex(member => member._id === leftUserId);\r\n          room.members.splice(leftUserIndex, 1);\r\n\r\n          // Check if there is an active chatroom\r\n          if (Object.keys(newActiveChatRoom).length !== 0) {\r\n            newActiveChatRoom.members.splice(leftUserIndex, 1);\r\n            newActiveChatRoom.moderator = leftRoom.data.moderator;\r\n          }\r\n          console.log(room);\r\n        }\r\n      });\r\n      // console.log(newChatRooms);\r\n      return {\r\n        ...state,\r\n        chatRooms: newChatRooms,\r\n        activeChatRoom: newActiveChatRoom,\r\n      };\r\n    }\r\n    case ADDED_USERS_TO_CHATROOM: {\r\n      const newChatRooms = [...state.chatRooms];\r\n      const newActiveChatRoom = { ...state.activeChatRoom };\r\n      console.log(action.payload);\r\n      console.log(newChatRooms);\r\n      console.log(newActiveChatRoom);\r\n\r\n      newChatRooms.map(room => {\r\n        if (room._id === action.payload.data._id) {\r\n          console.log('update chatroom');\r\n          console.log(room);\r\n          console.log(action.payload.data);\r\n          room.members = action.payload.data.members;\r\n\r\n          if (\r\n            Object.keys(newActiveChatRoom).length !== 0 &&\r\n            newActiveChatRoom._id === action.payload.data._id\r\n          ) {\r\n            newActiveChatRoom.members = action.payload.data.members;\r\n          }\r\n        }\r\n      });\r\n\r\n      console.log(newChatRooms);\r\n\r\n      return {\r\n        ...state,\r\n        chatrooms: newChatRooms,\r\n        // activeChatRoom:\r\n        //   newActiveChatRoom._id === action.payload.data._id\r\n        //     ? newActiveChatRoom\r\n        //     : state.activeChatRoom,\r\n        activeChatRoom: newActiveChatRoom,\r\n      };\r\n    }\r\n\r\n    case SET_UNREAD_MESSAGES: {\r\n      console.log(action.payload);\r\n\r\n      console.log(state);\r\n\r\n      // Of ik moet unread messages in de room pleuren van de props.chatRooms waar de render plaatsvind weet je wel. bij de object indrukken\r\n      return {\r\n        ...state,\r\n        unreadMessages: [...action.payload.newUnreadMessages],\r\n        totalUnread: action.payload.totalUnread,\r\n      };\r\n    }\r\n\r\n    case MARK_MESSAGES_READ: {\r\n      console.log(' MARK_MESSAGES_READ');\r\n      console.log(action.payload);\r\n      console.log(state);\r\n      let unreadMessages = [...state.unreadMessages];\r\n      let totalUnread = [state.totalUnread];\r\n\r\n      let roomIndex = unreadMessages.findIndex(\r\n        message => message.roomId === action.payload.chatRoomId && message,\r\n      );\r\n\r\n      totalUnread = totalUnread - unreadMessages[roomIndex].unreadMessages;\r\n\r\n      unreadMessages[roomIndex].unreadMessages = 0;\r\n\r\n      console.log(roomIndex);\r\n      return {\r\n        ...state,\r\n        unreadMessages: unreadMessages,\r\n        totalUnread: totalUnread,\r\n      };\r\n    }\r\n\r\n    case SET_NO_ACTIVE_CHATROOM: {\r\n      return {\r\n        ...state,\r\n        activeChatRoom: [],\r\n      };\r\n    }\r\n    case TOGGLE_CHAT: {\r\n      return {\r\n        ...state,\r\n        toggleFriendList: 'chats',\r\n      };\r\n    }\r\n    case TOGGLE_CONTACTS: {\r\n      return {\r\n        ...state,\r\n        toggleFriendList: 'contacts',\r\n      };\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\userReducer.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\themeReducer.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\reducers\\socketReducer.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\types.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatFriendsList.js",["142","143","144","145","146","147","148","149","150","151"],"import { useEffect } from 'react';\r\n\r\n// Redux\r\nimport { connect, useDispatch } from 'react-redux';\r\n\r\n// Redux actions\r\nimport { getAllUsers } from '../redux/actions/userActions';\r\nimport {\r\n  getSingleChatRoom,\r\n  getAllUserChatRooms,\r\n  createChatRoom,\r\n  markMessagesRead,\r\n  getAllUnreadMessages,\r\n} from '../redux/actions/chatMessageActions';\r\n\r\n// Types\r\nimport { TOGGLE_CHAT, TOGGLE_CONTACTS, SET_NO_ACTIVE_CHATROOM } from '../redux/types';\r\n\r\n// Components\r\nimport CreateGroupModal from '../util/CreateGroupModal';\r\nimport GroupChat from './GroupChat';\r\nimport { StyledBadge } from '../util/StyledBadge';\r\n\r\n// Helper functions\r\nimport { firstCharUpperCase } from '../util/helperFunctions';\r\n\r\n// MUI\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport List from '@material-ui/core/List';\r\nimport ListItem from '@material-ui/core/ListItem';\r\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\r\nimport ListItemText from '@material-ui/core/ListItemText';\r\nimport Avatar from '@material-ui/core/Avatar';\r\nimport Badge from '@material-ui/core/Badge';\r\nimport PeopleAltIcon from '@material-ui/icons/PeopleAlt';\r\nimport MessageIcon from '@material-ui/icons/Message';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n  chatButtons: {\r\n    position: 'sticky',\r\n    top: 0,\r\n    zIndex: 1000,\r\n    backgroundColor: theme.palette.background.paper,\r\n    justify: 'space-between',\r\n  },\r\n  noMessages: {\r\n    paddingTop: 30,\r\n    justifyContent: 'center',\r\n  },\r\n}));\r\n\r\nconst ChatFriendsList = props => {\r\n  // authroute calls getsAllUserRooms, which queries the chatrooms with {req.user._id} where the current logged in user is a member of.\r\n  // We add the chatrooms to the redux state, only chatrooms that have messages are rendered to CHATS\r\n  // we render the chatrooms, with the name of the member that is not the currentUser, sorted by the last created or received message on top.\r\n  // onCLick => getChatMessages from that room with the room._id + we socket.join('clickedRoom') server side, and leave all other rooms. (SERVER SIDE: NO LONGER TRUE)\r\n  // in socketManager we query the chatRooms where the user is a member, we loop through the rooms and socket.join them all.\r\n\r\n  const classes = useStyles();\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(() => {\r\n    props.getAllUsers();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    props.getAllUnreadMessages(props.user._id);\r\n  }, [props.lastMessages]);\r\n\r\n  console.log(props);\r\n\r\n  const { toggleFriendList } = props;\r\n\r\n  // check if there is a chatroom with the clicked on contact. create one if there is not.\r\n  const checkIfContactHasChatRoom = async clickedContact => {\r\n    // {{URL}}/api/v1/rooms?members[all]=605ca93de8a5cd08b04ae4e5&members[all]=6033a9fae16ec73670656ba2\r\n    const chatRoomQuery = await props.getAllUserChatRooms(\r\n      `members[all]=${clickedContact._id}&members[all]=${props.user._id}&members[size]=2&name[exists]=false`,\r\n    );\r\n\r\n    console.log(chatRoomQuery);\r\n    console.log(chatRoomQuery.chatRooms.length);\r\n\r\n    // let chatroom;\r\n    // props.chatRooms.forEach(room => {\r\n    //   room.members.forEach(member => {\r\n    //     if (clickedContact._id === member._id && room.members.length <= 2) {\r\n    //       chatroom = room;\r\n    //     }\r\n    //   });\r\n    // });\r\n    // console.log(chatroom);\r\n\r\n    // If there is a chatroom, set it as the activeChatRoom\r\n    if (chatRoomQuery.chatRooms.length) {\r\n      props.getSingleChatRoom(chatRoomQuery.chatRooms[0]._id);\r\n\r\n      // Origineel:\r\n      // props.getSingleChatRoom(chatroom._id);\r\n\r\n      // If the chatroom contains chatMessages, render 'chats'. If the chatroom does not contain chatMessages, stay in 'contacts'.\r\n      // chatroom.chatMessages.length > 0 && dispatch({ type: TOGGLE_CHAT });\r\n\r\n      if (chatRoomQuery.chatRooms[0].chatMessages.length > 0) {\r\n        dispatch({ type: TOGGLE_CHAT });\r\n        let memberId = chatRoomQuery.chatRooms[0].members.filter(\r\n          member => member._id !== props.user._id,\r\n        );\r\n        props.markMessagesRead(chatRoomQuery.chatRooms[0]._id);\r\n      }\r\n\r\n      // Origineel:\r\n      // if (chatroom.chatMessages.length > 0) {\r\n      //   dispatch({ type: TOGGLE_CHAT });\r\n      //   let memberId = chatroom.members.filter(member => member._id !== props.user._id);\r\n      //   props.markMessagesRead(chatroom._id, memberId);\r\n      // }\r\n    } else {\r\n      // There is no chatRoom, stay in 'contacts'\r\n      dispatch({ type: TOGGLE_CONTACTS });\r\n      console.log('no chatroom');\r\n\r\n      // TODO:\r\n      // Close modal on created group\r\n      // chat messages read by\r\n      // Group images?\r\n      // Secure API routes + register users + close registration\r\n\r\n      // chatmessages: [] at chatroomModel?\r\n      // If there is no chatroom found, create a new chatroom.\r\n      // When the chatRoom is created, send it: socket.emit(CREATED_CHAT_MESSAGE, res.data.doc) to the server.\r\n      // dispatch SET_ACTIVE_CHATROOM which updates the props.activeChatRoom of the current user to the newly created chatroom\r\n      // the server socket.joins(newChatRoom._id) with the current socket.\r\n      // Server emits EMIT_CREATED_CHATROOM to chatMessageArea\r\n      // dispatch CREATE_CHAT_ROOM which updates the props.chatrooms of the chatRoomsMembers, updating the state. can't create 2 rooms ✅\r\n      // socket.emit(MEMBERS_JOIN_CHAT_ROOMS, newCreatedChatRoomId) to the server, so all connected members join the new chat room.\r\n      // TODO: Notification on unread messages\r\n      props.createChatRoom(props.socket, null, props.user._id, clickedContact._id, props.user._id);\r\n    }\r\n  };\r\n\r\n  // const countTotalUnreadMessages = props.chatRooms.map(room => {\r\n  //   return room.chatMessages.filter(message => {\r\n  //     return message.read === false && message.userId !== props.user._id;\r\n  //   }).length;\r\n  // });\r\n\r\n  let totalUnreadMessages = [];\r\n  let unreadMessages = [];\r\n\r\n  // Map through the chat room array\r\n  // const countTotalUnreadMessages = props.chatRooms.map((room, i) => {\r\n  //   // Reset counter for the current room\r\n  //   let counter = 0;\r\n\r\n  //   // Push in the room id, and a count of 0 to the unread messages array\r\n  //   unreadMessages.push({ room: room._id, count: 0 });\r\n\r\n  //   // Map through the chatMessages of the current props.chatroom\r\n  //   room.chatMessages.map(message => {\r\n  //     // return message.read === false && message.userId !== props.user._id;\r\n\r\n  //     // map through the message.read array and try to find the userId of the current logged in user. save the value to the userIndex var (0, 1, -1)\r\n  //     let userIndex = message.read.findIndex(user => {\r\n  //       // console.log(message);\r\n  //       if (user === props.user._id) {\r\n  //         return true;\r\n  //       }\r\n  //     });\r\n  //     // console.log(userIndex);\r\n\r\n  //     // Whenever the userIndex is -1, the message is unread\r\n  //     if (userIndex === -1) {\r\n  //       // push the userindex to the TOTAL unreadMessages array.\r\n  //       totalUnreadMessages.push(userIndex);\r\n\r\n  //       // Update the counter for the current unread message in the current room\r\n  //       counter++;\r\n\r\n  //       // map through the unreadmessages array where the roomId is called item.room\r\n  //       props.unreadMessages.map(item => {\r\n  //         // if the item.room === message.chatRoomId update item.count to the total count for this room\r\n  //         if (item.roomId === message.chatRoomId) {\r\n  //           console.log(item);\r\n  //           item.count = item.unreadMessages;\r\n  //           room.unread = counter;\r\n  //           room.unread = item.unreadMessages;\r\n  //         }\r\n  //       });\r\n  //     }\r\n  //   });\r\n  //   // console.log(room);\r\n  // });\r\n\r\n  // unread fucking messages\r\n\r\n  props.chatRooms.map(room => {\r\n    console.log('code runs hereee');\r\n    room.chatMessages.map(message => {\r\n      props.unreadMessages.map(unreadMessage => {\r\n        if (unreadMessage.roomId === message.chatRoomId) {\r\n          room.unread = unreadMessage.unreadMessages;\r\n        }\r\n      });\r\n    });\r\n  });\r\n\r\n  // console.log(Object.values(unreadMessages.room));\r\n\r\n  // console.log(unreadMessages);\r\n  // console.log(totalUnreadMessages);\r\n  // console.log(totalUnreadMessages.length);\r\n\r\n  // if (countTotalUnreadMessages[0]) {\r\n  //   totalUnreadMessages = countTotalUnreadMessages.reduce((a, b) => a + b);\r\n  // }\r\n\r\n  return (\r\n    <List>\r\n      <Grid container className={classes.chatButtons}>\r\n        <Grid item xs={4} style={{ borderRight: '1px solid lightgrey' }}>\r\n          <ListItem\r\n            button\r\n            onClick={e => {\r\n              dispatch({ type: TOGGLE_CONTACTS });\r\n              dispatch({ type: SET_NO_ACTIVE_CHATROOM });\r\n              console.log(toggleFriendList);\r\n            }}>\r\n            <ListItemText style={{ textAlign: 'center' }}>\r\n              <Tooltip title='Contacten' placement='top-start' arrow interactive>\r\n                {/* Contacts */}\r\n                {props.theme === 'dark' ? <PeopleAltIcon /> : <PeopleAltIcon color='primary' />}\r\n              </Tooltip>\r\n            </ListItemText>\r\n          </ListItem>\r\n        </Grid>\r\n        <Grid item xs={4} style={{ borderRight: '1px solid lightgrey' }}>\r\n          <ListItem\r\n            style={{ justifyContent: 'center' }}\r\n            button\r\n            onClick={e => {\r\n              dispatch({ type: TOGGLE_CHAT });\r\n              dispatch({ type: SET_NO_ACTIVE_CHATROOM });\r\n              console.log(toggleFriendList);\r\n            }}>\r\n            {toggleFriendList === 'contacts' && props.totalUnread > 0 ? (\r\n              <Badge badgeContent={props.totalUnread} max={99} color='secondary'>\r\n                <ListItemText style={{ textAlign: 'center' }}>\r\n                  <Tooltip\r\n                    title={\r\n                      props.totalUnread > 1\r\n                        ? `${props.totalUnread} nieuwe berichten`\r\n                        : `${props.totalUnread} nieuw bericht`\r\n                    }\r\n                    placement='top-start'\r\n                    arrow\r\n                    interactive>\r\n                    {/* Chats */}\r\n                    {props.theme === 'dark' ? <MessageIcon /> : <MessageIcon color='primary' />}\r\n                  </Tooltip>\r\n                </ListItemText>\r\n              </Badge>\r\n            ) : (\r\n              <ListItemText style={{ textAlign: 'center' }}>\r\n                <Tooltip title='Berichten' placement='top-start' arrow interactive>\r\n                  {/* Chats */}\r\n                  {props.theme === 'dark' ? <MessageIcon /> : <MessageIcon color='primary' />}\r\n                </Tooltip>\r\n              </ListItemText>\r\n            )}\r\n          </ListItem>\r\n        </Grid>\r\n\r\n        {/* Add Group */}\r\n        <CreateGroupModal />\r\n      </Grid>\r\n\r\n      {/* Render chats with messages with more than 1 members (groups always include a name, rooms dont) */}\r\n      {/* Render group chats */}\r\n      {props.chatRooms && toggleFriendList === 'chats'\r\n        ? props.chatRooms.map(room => {\r\n            if (room.members.length >= 1 && room.name) {\r\n              return <GroupChat room={room} key={room._id} />;\r\n            }\r\n\r\n            // Render chats with messages with max 2 members\r\n            // Render ONLINE CHAT users: sorted: chat with last received message on top\r\n            return (\r\n              room.chatMessages.length > 0 &&\r\n              room.members.map(member => {\r\n                if (room.members.length === 2 && !room.name) {\r\n                  if (\r\n                    Object.values(props.connectedUsers).includes(member._id) &&\r\n                    member.username !== props.user.username\r\n                  ) {\r\n                    return (\r\n                      <ListItem\r\n                        button\r\n                        key={room._id}\r\n                        onClick={e => {\r\n                          console.log('click');\r\n                          console.log(`Room Id: ${room._id}`);\r\n                          props.getSingleChatRoom(room._id);\r\n\r\n                          let memberId = room.members.filter(\r\n                            member => member._id !== props.user._id,\r\n                          );\r\n\r\n                          props.markMessagesRead(room._id);\r\n\r\n                          // props.socket.emit('roomId', room._id);\r\n                        }}>\r\n                        <ListItemIcon>\r\n                          <StyledBadge\r\n                            overlap='circle'\r\n                            anchorOrigin={{\r\n                              vertical: 'bottom',\r\n                              horizontal: 'right',\r\n                            }}\r\n                            variant='dot'>\r\n                            <Avatar alt={member.username.toUpperCase()} src={member.avatar} />\r\n                          </StyledBadge>\r\n                        </ListItemIcon>\r\n                        <ListItemText primary={firstCharUpperCase(member.username)}></ListItemText>\r\n                        <Badge\r\n                          max={99}\r\n                          badgeContent={room._id !== props.activeChatRoom._id ? room.unread : 0}\r\n                          color='secondary'>\r\n                          <ListItemText\r\n                            secondary={props.lastMessages.map(lastMessage => {\r\n                              if (lastMessage && lastMessage.chatRoomId === room._id) {\r\n                                return lastMessage.body;\r\n                              }\r\n                              return null;\r\n                            })}\r\n                            align='right'></ListItemText>\r\n                        </Badge>\r\n                      </ListItem>\r\n                    );\r\n                    // Render OFFLINE CHAT users\r\n                  } else if (member.username !== props.user.username) {\r\n                    return (\r\n                      <ListItem\r\n                        button\r\n                        key={room._id}\r\n                        onClick={e => {\r\n                          console.log('click');\r\n                          console.log(`Room Id: ${room._id}`);\r\n                          props.getSingleChatRoom(room._id);\r\n\r\n                          let memberId = room.members.filter(\r\n                            member => member._id !== props.user._id,\r\n                          );\r\n\r\n                          props.markMessagesRead(room._id);\r\n                          // props.socket.emit('roomId', room._id);\r\n                        }}>\r\n                        <ListItemIcon>\r\n                          <Avatar alt={member.username.toUpperCase()} src={member.avatar} />\r\n                        </ListItemIcon>\r\n                        <ListItemText\r\n                          style={{\r\n                            marginRight: 10,\r\n                            minWidth: 213.52,\r\n                          }}\r\n                          primary={firstCharUpperCase(member.username)}>\r\n                          {firstCharUpperCase(member.username)}\r\n                        </ListItemText>\r\n\r\n                        <Badge\r\n                          max={9}\r\n                          badgeContent={room._id !== props.activeChatRoom._id ? room.unread : 0}\r\n                          color='secondary'>\r\n                          <ListItemText\r\n                            secondary={props.lastMessages.map(lastMessage => {\r\n                              if (lastMessage && lastMessage.chatRoomId === room._id) {\r\n                                return lastMessage.body;\r\n                              }\r\n                              return null;\r\n                            })}\r\n                            align='right'\r\n                          />\r\n                        </Badge>\r\n                      </ListItem>\r\n                    );\r\n                  }\r\n                }\r\n                return null;\r\n              })\r\n            );\r\n          })\r\n        : // Render ONLINE CONTACTS: sorted online users first\r\n          props.users &&\r\n          toggleFriendList === 'contacts' &&\r\n          props.users.map(user => {\r\n            if (\r\n              Object.values(props.connectedUsers).includes(user._id) &&\r\n              user.username !== props.user.username\r\n            ) {\r\n              return (\r\n                <ListItem\r\n                  button\r\n                  key={user._id}\r\n                  onClick={e => {\r\n                    console.log('clicked ONLINE contact');\r\n                    // console.log(props.chatRooms);\r\n                    // console.log(user._id);\r\n                    console.log(user);\r\n                    checkIfContactHasChatRoom(user);\r\n\r\n                    // console.log(`Room Id: ${room._id}`);\r\n                    // props.getSingleChatRoom(room._id);\r\n                    // props.socket.emit('roomId', room._id);\r\n                  }}>\r\n                  <ListItemIcon>\r\n                    <StyledBadge\r\n                      overlap='circle'\r\n                      anchorOrigin={{\r\n                        vertical: 'bottom',\r\n                        horizontal: 'right',\r\n                      }}\r\n                      variant='dot'>\r\n                      <Avatar alt={user.username.toUpperCase()} src={user.avatar} />\r\n                    </StyledBadge>\r\n                  </ListItemIcon>\r\n                  <ListItemText primary={firstCharUpperCase(user.username)}>\r\n                    {firstCharUpperCase(user.username)}\r\n                  </ListItemText>\r\n                </ListItem>\r\n              );\r\n            }\r\n            // Render OFFLINE CONTACTS\r\n            else if (user.username !== props.user.username) {\r\n              return (\r\n                <ListItem\r\n                  button\r\n                  key={user._id}\r\n                  onClick={e => {\r\n                    console.log('clicked OFFLINE contact');\r\n                    // console.log(props.chatRooms);\r\n                    // console.log(user._id);\r\n                    console.log(user);\r\n\r\n                    checkIfContactHasChatRoom(user);\r\n                  }}>\r\n                  <ListItemIcon>\r\n                    <Avatar alt={user.username.toUpperCase()} src={user.avatar} />\r\n                  </ListItemIcon>\r\n                  <ListItemText primary={firstCharUpperCase(user.username)}>\r\n                    {firstCharUpperCase(user.username)}\r\n                  </ListItemText>\r\n                  <ListItemText secondary='Offline' align='right'></ListItemText>\r\n                </ListItem>\r\n              );\r\n            }\r\n            return null;\r\n          })}\r\n      {props.chatRooms.length === 0 && toggleFriendList === 'chats' && (\r\n        <ListItem className={classes.noMessages}>Geen berichten gevonden...</ListItem>\r\n      )}\r\n    </List>\r\n  );\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    socket: state.socket.socket,\r\n    user: state.user.user,\r\n    toggleFriendList: state.chat.toggleFriendList,\r\n    chatRooms: state.chat.chatRooms,\r\n    totalUnread: state.chat.totalUnread,\r\n    unreadMessages: state.chat.unreadMessages,\r\n    lastMessages: state.chat.lastMessages,\r\n    activeChatRoom: state.chat.activeChatRoom,\r\n    connectedUsers: state.user.connectedUsers,\r\n    users: state.user.users,\r\n    theme: state.theme.theme,\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, {\r\n  getSingleChatRoom,\r\n  getAllUserChatRooms,\r\n  getAllUsers,\r\n  createChatRoom,\r\n  markMessagesRead,\r\n  getAllUnreadMessages,\r\n})(ChatFriendsList);\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatMessageArea.js",["152","153","154"],"// React\r\nimport { useEffect, useRef } from 'react';\r\n\r\n// Redux\r\nimport { connect, useDispatch } from 'react-redux';\r\n\r\n// Redux Actions\r\nimport {\r\n  createChatMessage,\r\n  deleteChatMessage,\r\n  emitCreateChatMessageFromServerToAllClients,\r\n  emitLastChatMessage,\r\n  emitDeleteChatMessageFromServerToAllClients,\r\n  getAllUserChatRooms,\r\n  getAllUnreadMessages,\r\n  markMessagesRead,\r\n} from '../redux/actions/chatMessageActions';\r\n\r\nimport {\r\n  OUTPUT_CHAT_MESSAGE,\r\n  DELETED_CHAT_MESSAGE,\r\n  CREATE_CHAT_ROOM,\r\n  EMIT_CREATED_CHAT_ROOM,\r\n  MEMBERS_JOIN_NEW_CHAT_ROOM,\r\n  TOGGLE_CHAT,\r\n} from '../redux/types';\r\n\r\nimport moment from 'moment';\r\n\r\n// MUI\r\nimport { makeStyles } from '@material-ui/core';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport List from '@material-ui/core/List';\r\nimport ListItem from '@material-ui/core/ListItem';\r\nimport ListItemText from '@material-ui/core/ListItemText';\r\n\r\nconst useStyles = makeStyles(theme => {\r\n  console.log(theme);\r\n  return {\r\n    messageBody: {\r\n      backgroundColor: theme.palette.primary.main,\r\n      color: '#fff',\r\n      paddingTop: 12.5,\r\n      paddingBottom: 12.5,\r\n      paddingLeft: 20,\r\n      paddingRight: 20,\r\n      borderRadius: 100 / 2,\r\n      boxShadow:\r\n        '0px 3px 5px -1px rgb(0 0 0 / 20%), 0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%)',\r\n      display: 'inline-flex',\r\n    },\r\n  };\r\n});\r\n\r\nconst ChatMessageArea = props => {\r\n  const dispatch = useDispatch();\r\n  const classes = useStyles();\r\n\r\n  console.log(classes);\r\n\r\n  const {\r\n    user,\r\n    socket,\r\n    activeChatRoom,\r\n    emitCreateChatMessageFromServerToAllClients,\r\n    emitLastChatMessage,\r\n    emitDeleteChatMessageFromServerToAllClients,\r\n    getAllUserChatRooms,\r\n    getAllUnreadMessages,\r\n    markMessagesRead,\r\n  } = props;\r\n\r\n  //   On changes to the chatMessages in the state\r\n  useEffect(() => {\r\n    // Dont stack multiple callbacks, just execute once\r\n\r\n    if (socket._callbacks !== undefined && socket._callbacks['$OUTPUT_CHAT_MESSAGE']) {\r\n      socket._callbacks['$OUTPUT_CHAT_MESSAGE'].length = 0;\r\n    }\r\n\r\n    if (socket._callbacks !== undefined && socket._callbacks['$EMIT_CREATED_CHAT_ROOM']) {\r\n      socket._callbacks['$EMIT_CREATED_CHAT_ROOM'].length = 0;\r\n    }\r\n\r\n    if (socket._callbacks !== undefined && socket._callbacks['$DELETED_CHAT_MESSAGE']) {\r\n      socket._callbacks['$DELETED_CHAT_MESSAGE'].length = 0;\r\n    }\r\n\r\n    // if (socket._callbacks !== undefined) {\r\n    //   Object.keys(socket._callbacks).map(callback => {\r\n    //     if (socket._callbacks[callback]) {\r\n    //       socket._callbacks[callback].length = 0;\r\n    //     }\r\n    //   });\r\n    // }\r\n\r\n    // Listen to incoming chatMessages from the backend\r\n    socket.on(OUTPUT_CHAT_MESSAGE, messageFromBackend => {\r\n      // Dispatch messageFromBackend to the chatMessageReducer, to update the state/props to rerender\r\n      // props.createChatMessage(messageFromBackend);\r\n      console.log('message from backend:');\r\n      console.log(messageFromBackend);\r\n\r\n      // updates the lastChatMessage at the friendsList for both the sender and the receiver of the message.\r\n      emitLastChatMessage(messageFromBackend);\r\n\r\n      // Reorder friendList to show latest conversation on top (SENDER)\r\n      getAllUserChatRooms(`members=${user._id}`);\r\n      // getAllUnreadMessages(user._id);\r\n\r\n      // toggle chat for the message sender\r\n      if (user._id === messageFromBackend.userId) dispatch({ type: TOGGLE_CHAT });\r\n\r\n      // Dispatch from here, so that the redux state is updated for all clients in the room.\r\n      if (messageFromBackend.chatRoomId === props.activeChatRoom._id) {\r\n        console.log('only runs when activeChatRoom === messageFromBackend.chatRoomId');\r\n        emitCreateChatMessageFromServerToAllClients(messageFromBackend);\r\n\r\n        // Scroll to bottom on send and receive message when the activeChatRoom === room that message is send to\r\n        // chatEnd.current.scrollIntoView({ behavior: 'smooth' });\r\n        console.log(props.chatMessages.length);\r\n        if (props.chatMessages.length >= 10) {\r\n          scrollIntoLastMessage.current.childNodes[9].scrollIntoView({\r\n            behavior: 'smooth',\r\n          });\r\n        } else if (props.chatMessages.length > 0) {\r\n          scrollIntoLastMessage.current.childNodes[props.chatMessages.length - 1].scrollIntoView({\r\n            behavior: 'smooth',\r\n          });\r\n        }\r\n\r\n        // When the received message is in the activeChatRoom, mark the message as read\r\n        let memberId = props.activeChatRoom.members.filter(member => member._id !== user._id);\r\n        markMessagesRead(props.activeChatRoom._id);\r\n      }\r\n    });\r\n\r\n    // Listen to incoming ID's from deleted chatMessages from the backend / db\r\n    socket.on(DELETED_CHAT_MESSAGE, messageIdFromBackEnd => {\r\n      emitDeleteChatMessageFromServerToAllClients(messageIdFromBackEnd);\r\n    });\r\n\r\n    // When a new chatRoom is created, update the props.chatRooms for all members.\r\n    socket.on(EMIT_CREATED_CHAT_ROOM, createdChatRoom => {\r\n      console.log(createdChatRoom);\r\n\r\n      // if the the current logged in user is a member of the new created chatroom, dispatch add the chatroom to the state. emit the chatroom to the server from all members, so they can all socket.join(theNewChatRoom) serverside\r\n      createdChatRoom.members.forEach(member => {\r\n        if (member._id === user._id) {\r\n          console.log(member);\r\n          dispatch({ type: CREATE_CHAT_ROOM, payload: createdChatRoom });\r\n          socket.emit(MEMBERS_JOIN_NEW_CHAT_ROOM, createdChatRoom);\r\n        }\r\n      });\r\n    });\r\n  }, [\r\n    props.chatMessages.length,\r\n    socket,\r\n    activeChatRoom,\r\n    emitCreateChatMessageFromServerToAllClients,\r\n    emitLastChatMessage,\r\n    emitDeleteChatMessageFromServerToAllClients,\r\n  ]);\r\n\r\n  // Scroll to bottom on new chatMessage\r\n  const chatEnd = useRef(null);\r\n  useEffect(() => {\r\n    chatEnd.current.scrollIntoView({ behavior: 'smooth' });\r\n  }, [activeChatRoom]);\r\n\r\n  // Gewoon omhoog scrollen werkt perfect\r\n  // Typen zonder omhoog te scrollen werkt perfect\r\n  // Eerst scrollen dan typen, werkt\r\n  // Eerst typen, dan scrollen, dan typen werkt\r\n\r\n  const scrollIntoLastMessage = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // childTen === pos 9, arrays 0 based\r\n    let childTen = scrollIntoLastMessage.current.childNodes[9]?.innerText.split(/\\r?\\n/)[2];\r\n    console.log(scrollIntoLastMessage.current.childNodes);\r\n    // let childTen = scrollIntoLastMessage.current.childNodes[props.chatMessages.length - 1]?.innerText.split(/\\r?\\n/)[2];\r\n    let lastMessage = props.chatMessages[props.chatMessages.length - 1]?.body;\r\n\r\n    console.log(childTen);\r\n    console.log(lastMessage);\r\n    if (props.chatMessages.length > 10) {\r\n      // if the chatMessages array length is divisible by exactly 10, scroll into the new 10th which is the top message\r\n      if (scrollIntoLastMessage.current.childNodes[10] && props.chatMessages.length % 10 === 0) {\r\n        scrollIntoLastMessage.current.childNodes[10].scrollIntoView();\r\n        console.log('if');\r\n        // if the chatMessages array length is not divisible by exactly 10, e.g. 26, substract the array length (20) of the 26, and scroll into the 6\r\n\r\n        // Not divisible by 10 === end of messages\r\n      } else if (\r\n        scrollIntoLastMessage.current.childNodes[10] &&\r\n        props.chatMessages.length % 10 !== 0\r\n      ) {\r\n        console.log('not divisible by 10');\r\n        console.log(props.chatMessages.length);\r\n        let scrollLength =\r\n          props.chatMessages.length - Math.floor(props.chatMessages.length / 10) * 10;\r\n        console.log(scrollLength);\r\n        scrollIntoLastMessage.current.childNodes[scrollLength].scrollIntoView();\r\n      } else {\r\n        console.log('else');\r\n        // chatEnd.current.scrollIntoView({ behavior: 'smooth' });\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <List ref={scrollIntoLastMessage}>\r\n        {props.activeChatRoom.chatMessages ? (\r\n          props.chatMessages.map(message => {\r\n            return (\r\n              <ListItem key={message._id}>\r\n                <Grid container>\r\n                  <Grid item xs={12}>\r\n                    {/* username */}\r\n                    <ListItemText\r\n                      style={{ display: message.systemMessage === true && 'none' }}\r\n                      align={props.user._id === message.userId ? 'right' : 'left'}\r\n                      secondary={message.username}></ListItemText>\r\n\r\n                    {/* chat message body */}\r\n                    <ListItemText\r\n                      className={message.systemMessage ? 'leftGroup' : ''}\r\n                      align={props.user._id === message.userId ? 'right' : 'left'}>\r\n                      <ListItemText\r\n                        className={classes.messageBody}\r\n                        align={props.user._id === message.userId ? 'right' : 'left'}\r\n                        style={{\r\n                          backgroundColor: props.user._id !== message.userId && '#9c27b0',\r\n                        }}>\r\n                        {message.body}\r\n                      </ListItemText>\r\n                    </ListItemText>\r\n                  </Grid>\r\n\r\n                  {/* timestamp */}\r\n                  <Grid item xs={12}>\r\n                    <ListItemText\r\n                      className={message.systemMessage ? 'leftGroup-timestamp' : ''}\r\n                      align={props.user._id === message.userId ? 'right' : 'left'}\r\n                      secondary={moment(message.createdAt).fromNow()}></ListItemText>\r\n                  </Grid>\r\n                </Grid>\r\n              </ListItem>\r\n            );\r\n          })\r\n        ) : (\r\n          <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\r\n            Selecteer een gesprek\r\n          </div>\r\n        )}\r\n\r\n        <div className={'test'} ref={chatEnd} />\r\n      </List>\r\n    </>\r\n  );\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    socket: state.socket.socket,\r\n    chatMessages: state.chat.chatMessages,\r\n    user: state.user.user,\r\n    activeChatRoom: state.chat.activeChatRoom,\r\n    theme: state.theme.theme,\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, {\r\n  createChatMessage,\r\n  deleteChatMessage,\r\n  emitCreateChatMessageFromServerToAllClients,\r\n  emitLastChatMessage,\r\n  emitDeleteChatMessageFromServerToAllClients,\r\n  getAllUserChatRooms,\r\n  getAllUnreadMessages,\r\n  markMessagesRead,\r\n})(ChatMessageArea);\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatUserData.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatHeader.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\ChatInput.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\actions\\authActions.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\actions\\chatMessageActions.js",["155"],"import {\r\n  GET_ALL_CHAT_MESSAGES,\r\n  CREATE_CHAT_MESSAGE,\r\n  DELETE_CHAT_MESSAGE,\r\n  SET_ACTIVE_CHATROOM,\r\n  SET_USER_CHATROOMS,\r\n  SET_LAST_CHAT_MESSAGE,\r\n  SET_UNREAD_MESSAGES,\r\n  MARK_MESSAGES_READ,\r\n  CREATED_CHAT_ROOM,\r\n  SET_ERRORS,\r\n  LEAVE_CHATROOM,\r\n  ADD_USERS_TO_CHATROOM,\r\n  SET_NO_ACTIVE_CHATROOM,\r\n} from '../types';\r\nimport axios from '../../config/axios';\r\n\r\nconst baseUrl = 'http://localhost:1337/api/v1/chatMessages';\r\n\r\n// REDUX\r\nexport const getAllChatMessages = (chatRoomId, skip) => dispatch => {\r\n  // dispatch({ type: LOADING_DATA });\r\n  if (!chatRoomId) return console.error('GEEN CHATROOMID');\r\n\r\n  axios\r\n    .get(`${baseUrl}?skip=${skip}&chatRoomId=${chatRoomId}`)\r\n    .then(res => {\r\n      console.log(res);\r\n      if (res.data.chatMessages.length > 0) {\r\n        dispatch({\r\n          type: GET_ALL_CHAT_MESSAGES,\r\n          payload: res.data.chatMessages,\r\n        });\r\n      }\r\n    })\r\n    .catch(err => {\r\n      console.log(err);\r\n      // dispatch({\r\n      //   type: SET_ERRORS,\r\n      //   payload: err.response.data,\r\n      // });\r\n    });\r\n};\r\n\r\n// Get single chatRoom which include a virtual populate of the chatMessages\r\nexport const getSingleChatRoom = roomId => dispatch => {\r\n  axios\r\n    .get(`http://localhost:1337/api/v1/rooms/${roomId}`)\r\n    .then(res => {\r\n      console.log(res.data.doc.chatMessages);\r\n      dispatch({ type: SET_ACTIVE_CHATROOM, payload: res.data.doc });\r\n    })\r\n    .catch(err => {\r\n      console.log(err);\r\n    });\r\n};\r\n\r\n// GetAllRooms({members: \"req.user._id\"}) // gets all the chatrooms where the currentUser is a member\r\nexport const getAllUserChatRooms = queryString => dispatch => {\r\n  console.log('running getAllUserChatRooms');\r\n\r\n  console.log(queryString);\r\n\r\n  return axios\r\n    .get(`http://localhost:1337/api/v1/rooms?${queryString}`)\r\n    .then(res => {\r\n      console.log(res.data);\r\n\r\n      if (!queryString.includes('[all]')) {\r\n        console.log('query does not include [all], dispatch SET_USER_CHATROOMS');\r\n        dispatch({ type: SET_USER_CHATROOMS, payload: res.data.chatRooms });\r\n      }\r\n      return res.data;\r\n    })\r\n    .catch(err => console.log(err));\r\n};\r\n\r\nexport const createChatRoom = (socket, name, moderator, ...members) => dispatch => {\r\n  console.log(socket);\r\n  let newChatRoom = {\r\n    moderator: moderator,\r\n    members: members,\r\n  };\r\n\r\n  console.log(newChatRoom);\r\n  console.log(members);\r\n  console.log(...members);\r\n\r\n  if (newChatRoom.members.length === 2) {\r\n    console.log('createChatRoom with 2 members');\r\n    axios\r\n      .post(`http://localhost:1337/api/v1/rooms`, newChatRoom)\r\n      .then(res => {\r\n        console.log(res.data);\r\n\r\n        if (res.data) {\r\n          socket.emit(CREATED_CHAT_ROOM, res.data.doc);\r\n          dispatch({ type: SET_ACTIVE_CHATROOM, payload: res.data.doc });\r\n        }\r\n      })\r\n      .catch(err => console.log(err));\r\n  } else {\r\n    console.log('create chatRoom with > 2 members');\r\n\r\n    if (name.length < 1) {\r\n      console.log('Groepsnaam is te kort');\r\n      return dispatch({\r\n        type: SET_ERRORS,\r\n        payload: 'Groepsnaam is te kort',\r\n      });\r\n    } else if (name.length > 25) {\r\n      console.log('Groepsnaam is te lang, gebruik maximaal 20 tekens.');\r\n      return dispatch({\r\n        type: SET_ERRORS,\r\n        payload: 'Groepsnaam is te lang, gebruik maximaal 20 tekens.',\r\n      });\r\n    }\r\n\r\n    // members: ['60599e90e50ae834b8a4db37', '6059a170e50ae834b8a4db4c'];\r\n    console.log(Object.values(...members));\r\n    newChatRoom = {\r\n      name: name,\r\n      moderator: moderator,\r\n      members: Object.values(...members),\r\n    };\r\n\r\n    console.log(newChatRoom);\r\n\r\n    axios\r\n      .post(`http://localhost:1337/api/v1/rooms`, newChatRoom)\r\n      .then(res => {\r\n        console.log(res.data);\r\n        createSystemMessage(res.data.doc._id, `Welkom in de chatgroep: '${newChatRoom.name}'`);\r\n\r\n        socket.emit(CREATED_CHAT_ROOM, res.data.doc);\r\n\r\n        dispatch({ type: SET_ACTIVE_CHATROOM, payload: res.data.doc });\r\n      })\r\n      .catch(err => {\r\n        console.log(err.response.data);\r\n        return dispatch({ type: SET_ERRORS, payload: err.response.data.message });\r\n      });\r\n  }\r\n};\r\n\r\nexport const leaveChatRoom = (socket, roomId, user) => dispatch => {\r\n  console.log('running leaveChatRoom');\r\n  axios\r\n    .patch(`/api/v1/rooms/${roomId}/leaveChatRoom`)\r\n    .then(res => {\r\n      console.log(res.data);\r\n      dispatch({ type: SET_NO_ACTIVE_CHATROOM });\r\n      dispatch({ type: LEAVE_CHATROOM, payload: res.data });\r\n      socket.emit(LEAVE_CHATROOM, roomId, user, res.data);\r\n\r\n      createSystemMessage(roomId, `${user.username} heeft de groep verlaten.`);\r\n\r\n      // New moderator is \"username\" message:\r\n      res.data.data.members.map(member => {\r\n        if (member._id === res.data.data.moderator) {\r\n          createSystemMessage(roomId, `${member.username} is de groepsbeheerder.`);\r\n        }\r\n      });\r\n    })\r\n    .catch(err => {\r\n      console.log(err.response);\r\n      console.log(err.message);\r\n      dispatch({ type: SET_NO_ACTIVE_CHATROOM });\r\n      dispatch({ type: LEAVE_CHATROOM, payload: { data: { _id: roomId } } });\r\n    });\r\n};\r\n\r\n// Update we use for adding new users to the chatroom from the joinChatRoomModal\r\n// TODO: EMIT UPDATE STATE FOR ALL USERS IN THE ROOM, TO SHOW THAT THE ACTIVECHATROOM, AND THE FRIENDSLIST REFLECTS THE ADDED USER\r\n// ERROR HANDLING ON TOO MANY OR NOT ENOUGH USERS ETC. IF THE USER IS ALREADY PRESENT\r\nexport const updateChatRoom = (socket, roomId, socketIds, ...members) => dispatch => {\r\n  console.log('running update chatroom');\r\n  let chatRoom = {\r\n    members: Object.values(...members),\r\n  };\r\n\r\n  console.log(chatRoom);\r\n  axios\r\n    .patch(`/api/v1/rooms/${roomId}`, chatRoom)\r\n    .then(res => {\r\n      console.log(res.data);\r\n\r\n      // send the new room and socket ids to the server\r\n      socket.emit(ADD_USERS_TO_CHATROOM, res.data, socketIds);\r\n\r\n      // Array of the newly added members\r\n      let welcomeUsers = res.data.data.members.slice(\r\n        res.data.data.members.length - socketIds.length,\r\n      );\r\n\r\n      console.log(welcomeUsers);\r\n\r\n      // Welcome the new members to the room with a message, also updating the state for the new users\r\n\r\n      if (welcomeUsers.length >= 1) {\r\n        createSystemMessage(\r\n          roomId,\r\n          `${welcomeUsers.map(user => user && ` ${user.username}`)} welkom in de chatgroep!`,\r\n        );\r\n      } else {\r\n        createSystemMessage(roomId, `Nieuwe leden, welkom in de chatgroep!`);\r\n      }\r\n    })\r\n    .catch(err => console.log(err));\r\n};\r\n\r\n// Create Single Chat Message SEND ALONG COOKIE PROTECT ROUTE\r\nexport const createChatMessage = chatMessage => dispatch => {\r\n  console.log(chatMessage);\r\n  // dispatch({ type: LOADING_DATA });\r\n\r\n  axios\r\n    .post(`${baseUrl}`, chatMessage)\r\n    .then(res => {\r\n      console.log(res);\r\n      // dispatch({\r\n      //   type: CREATE_CHAT_MESSAGE,\r\n      //   payload: res.data.chatMessage,\r\n      // });\r\n    })\r\n    .catch(err => {\r\n      console.log(err.response);\r\n      // Redirect to log in page when not logged in\r\n      window.location.replace('/login');\r\n    });\r\n};\r\n\r\nexport const createSystemMessage = (roomId, message) => {\r\n  console.log('running create system message');\r\n  axios\r\n    .post(`${baseUrl}/createSystemMessage`, { chatRoomId: roomId, body: message })\r\n    .then(res => {\r\n      console.log(res);\r\n    })\r\n    .catch(err => {\r\n      console.log(err);\r\n    });\r\n};\r\n\r\n// Get single chatRoom which include a virtual populate of the chatMessages\r\nexport const getAllUnreadMessages = userId => dispatch => {\r\n  console.log('running getAllUnreadMessages');\r\n  axios\r\n    .get(`http://localhost:1337/api/v1/rooms/getAllUnreadMessages?[members]=${userId}`)\r\n    .then(res => {\r\n      console.log(res.data.results);\r\n\r\n      let newUnreadMessages = [...res.data.results.roomsWithUnreadMessages];\r\n      const { totalUnread } = res.data.results;\r\n\r\n      console.log(newUnreadMessages);\r\n\r\n      // let array = [];\r\n\r\n      // newUnreadMessages.map((room, i) => {\r\n      //   i = room.roomId;\r\n      //   room[i] = i;\r\n\r\n      //   array[i] = room.unreadMessages;\r\n\r\n      //   newUnreadMessages[i] = room.unreadMessages;\r\n\r\n      //   // delete room.roomId;\r\n      //   console.log(room);\r\n      // });\r\n\r\n      // console.log(array);\r\n\r\n      console.log(newUnreadMessages);\r\n\r\n      dispatch({ type: SET_UNREAD_MESSAGES, payload: { newUnreadMessages, totalUnread } });\r\n    })\r\n    .catch(err => {\r\n      console.log(err);\r\n    });\r\n};\r\n\r\n// MemberId is the OTHER member in the room, not you. only set messages to read you've received\r\nexport const markMessagesRead = roomId => dispatch => {\r\n  axios\r\n    .patch(baseUrl, { chatRoomId: roomId })\r\n    .then(res => {\r\n      console.log(res);\r\n\r\n      dispatch({ type: MARK_MESSAGES_READ, payload: res.data });\r\n    })\r\n    .catch(err => console.log(err));\r\n};\r\n\r\n// Takes in the message from backend after change in db. emit to all connected clients.\r\nexport const emitCreateChatMessageFromServerToAllClients = messageFromBackend => dispatch => {\r\n  dispatch({\r\n    type: CREATE_CHAT_MESSAGE,\r\n    payload: messageFromBackend,\r\n  });\r\n};\r\n\r\n// Takes in the message from backend after change in db. to update the state for all connected clients, not just your own state.\r\nexport const emitLastChatMessage = messageFromBackend => dispatch => {\r\n  dispatch({\r\n    type: SET_LAST_CHAT_MESSAGE,\r\n    payload: messageFromBackend,\r\n  });\r\n};\r\n\r\n// Delete Single Chat Message REDUX\r\nexport const deleteChatMessage = chatMessageId => dispatch => {\r\n  axios\r\n    .delete(`${baseUrl}/${chatMessageId}`)\r\n    .then(res => {\r\n      console.log(res);\r\n    })\r\n    .catch(err => {\r\n      console.log(err);\r\n    });\r\n};\r\n\r\n// Takes in the message from backend after change in db. emit to all connected clients.\r\nexport const emitDeleteChatMessageFromServerToAllClients = messageFromBackend => dispatch => {\r\n  dispatch({\r\n    type: DELETE_CHAT_MESSAGE,\r\n    payload: messageFromBackend,\r\n  });\r\n};\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\redux\\actions\\userActions.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\config\\axios.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\Components\\GroupChat.js",["156","157"],"import { useEffect } from 'react';\r\n// Redux\r\nimport { connect, useDispatch } from 'react-redux';\r\n\r\n// Redux ChatMessage Actions\r\nimport {\r\n  createChatMessage,\r\n  getSingleChatRoom,\r\n  markMessagesRead,\r\n  createSystemMessage,\r\n} from '../redux/actions/chatMessageActions';\r\n\r\n// Redux Types\r\nimport { LEFT_CHATROOM } from '../redux/types';\r\n\r\n// MUI\r\nimport ListItem from '@material-ui/core/ListItem';\r\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\r\nimport ListItemText from '@material-ui/core/ListItemText';\r\nimport AvatarGroup from '@material-ui/lab/AvatarGroup';\r\nimport Avatar from '@material-ui/core/Avatar';\r\nimport Badge from '@material-ui/core/Badge';\r\n\r\nconst GroupChat = props => {\r\n  console.log(props);\r\n  const { room, socket } = props;\r\n\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(() => {\r\n    if (socket._callbacks !== undefined && socket._callbacks['$LEFT_CHATROOM']) {\r\n      socket._callbacks['$LEFT_CHATROOM'].length = 0;\r\n    }\r\n\r\n    socket.on(LEFT_CHATROOM, ({ roomId, leftUserId, username, leftRoom }) => {\r\n      console.log(socket);\r\n      console.log(roomId);\r\n      console.log(leftUserId);\r\n      console.log(leftRoom);\r\n\r\n      dispatch({ type: LEFT_CHATROOM, payload: { roomId, leftUserId, username, leftRoom } });\r\n    });\r\n  }, [props.chatRooms]);\r\n\r\n  return (\r\n    <ListItem\r\n      key={room._id}\r\n      button\r\n      onClick={e => {\r\n        console.log('click');\r\n        console.log(room);\r\n        console.log(`Room Id: ${room._id}`);\r\n        props.getSingleChatRoom(room._id);\r\n\r\n        let memberId = room.members.filter(member => member._id !== props.user._id);\r\n\r\n        //   messageReadBy =  read\r\n        props.markMessagesRead(room._id);\r\n      }}>\r\n      <ListItemIcon>\r\n        <AvatarGroup max={2} spacing='medium'>\r\n          {room.members.map(member => {\r\n            if (member._id !== props.user._id) {\r\n              return <Avatar alt={member.username} src={member.avatar} key={member._id} />;\r\n\r\n              // Return own avatar if you are the only member\r\n            } else if (room.members.length === 1) {\r\n              return <Avatar alt={member.username} src={member.avatar} key={member._id} />;\r\n            }\r\n            return null;\r\n          })}\r\n        </AvatarGroup>\r\n      </ListItemIcon>\r\n      <ListItemText\r\n        primary={room.name}\r\n        style={{\r\n          minWidth: 179.52,\r\n          marginLeft: 10,\r\n          marginRight: 10,\r\n        }}></ListItemText>\r\n      <Badge\r\n        max={99}\r\n        badgeContent={room._id !== props.activeChatRoom._id ? room.unread : 0}\r\n        color='secondary'>\r\n        <ListItemText\r\n          secondary={props.lastMessages.map(lastMessage => {\r\n            if (lastMessage && lastMessage.chatRoomId === room._id) {\r\n              return lastMessage.body;\r\n            }\r\n            return null;\r\n          })}\r\n          align='right'></ListItemText>\r\n      </Badge>\r\n    </ListItem>\r\n  );\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    socket: state.socket.socket,\r\n    user: state.user.user,\r\n    toggleFriendList: state.chat.toggleFriendList,\r\n    chatRooms: state.chat.chatRooms,\r\n    lastMessages: state.chat.lastMessages,\r\n    activeChatRoom: state.chat.activeChatRoom,\r\n    connectedUsers: state.user.connectedUsers,\r\n    users: state.user.users,\r\n    theme: state.theme.theme,\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, {\r\n  getSingleChatRoom,\r\n  markMessagesRead,\r\n  createChatMessage,\r\n  createSystemMessage,\r\n})(GroupChat);\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\helperFunctions.js",["158"],"export const firstCharUpperCase = string => string.slice(0, 1)[0].toUpperCase() + string.slice(1);\r\n\r\nfunction hasDuplicates(arr) {\r\n  return arr.some(x => arr.indexOf(x) !== arr.lastIndexOf(x));\r\n}\r\n\r\n// Remove indexes\r\n// let indexes = [0, 6, 8]\r\n// function spliceUserIndexes(arr) {\r\n//   let remove = indexes;\r\n//   for (let i = remove.length - 1; i >= 0; i--) {\r\n//     arr.splice(remove[i], 1);\r\n//   }\r\n// }\r\n","C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\CreateGroupModal.js",["159"],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\StyledBadge.js",[],"C:\\Users\\gebruiker\\React\\mern\\frontend\\src\\util\\joinChatRoomModal.js",["160","161","162","163"],"import { useEffect, useState } from 'react';\r\n\r\n// Redux\r\nimport { connect, useDispatch } from 'react-redux';\r\n\r\n// Redux chatMessage actions\r\nimport { updateChatRoom } from '../redux/actions/chatMessageActions';\r\n\r\n// Types\r\nimport { SET_ERRORS, ADDED_USERS_TO_CHATROOM } from '../redux/types';\r\n\r\n// Helper\r\nimport { firstCharUpperCase } from '../util/helperFunctions';\r\n\r\n// MUI\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport Modal from '@material-ui/core/Modal';\r\nimport Avatar from '@material-ui/core/Avatar';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport List from '@material-ui/core/List';\r\nimport ListItem from '@material-ui/core/ListItem';\r\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\r\nimport ListItemText from '@material-ui/core/ListItemText';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardHeader from '@material-ui/core/CardHeader';\r\nimport Checkbox from '@material-ui/core/Checkbox';\r\nimport Button from '@material-ui/core/Button';\r\nimport Divider from '@material-ui/core/Divider';\r\nimport MenuItem from '@material-ui/core/MenuItem';\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n  root: {\r\n    margin: 'auto',\r\n    width: 'fit-content',\r\n    border: 'none',\r\n    outline: 'none',\r\n  },\r\n  cardHeader: {\r\n    padding: theme.spacing(1, 2),\r\n  },\r\n  list: {\r\n    width: 300,\r\n    height: '50vh',\r\n    backgroundColor: theme.palette.background.paper,\r\n    overflow: 'auto',\r\n  },\r\n  button: {\r\n    margin: theme.spacing(0.5, 0),\r\n    backgroundColor: theme.palette.background.paper,\r\n  },\r\n  input: {\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    alignItems: 'center',\r\n\r\n    '& > *': {\r\n      margin: theme.spacing(1),\r\n      width: '25ch',\r\n    },\r\n  },\r\n}));\r\n\r\nfunction not(a, b) {\r\n  return a.filter(value => b.indexOf(value) === -1);\r\n}\r\n\r\nfunction intersection(a, b) {\r\n  return a.filter(value => b.indexOf(value) !== -1);\r\n}\r\n\r\nfunction union(a, b) {\r\n  return [...a, ...not(b, a)];\r\n}\r\n\r\nconst JoinChatRoomModal = props => {\r\n  const dispatch = useDispatch();\r\n  const classes = useStyles();\r\n  const [open, setOpen] = useState(false);\r\n  const [checked, setChecked] = useState([]);\r\n  const [left, setLeft] = useState([]);\r\n  const [right, setRight] = useState([]);\r\n\r\n  const leftChecked = intersection(checked, left);\r\n  const rightChecked = intersection(checked, right);\r\n\r\n  const { socket } = props;\r\n\r\n  const handleOpen = () => {\r\n    setOpen(true);\r\n  };\r\n\r\n  const handleClose = () => {\r\n    setOpen(false);\r\n    setRight([]);\r\n  };\r\n\r\n  const handleToggle = value => () => {\r\n    const currentIndex = checked.indexOf(value);\r\n    const newChecked = [...checked];\r\n\r\n    if (currentIndex === -1) {\r\n      newChecked.push(value);\r\n    } else {\r\n      newChecked.splice(currentIndex, 1);\r\n    }\r\n\r\n    setChecked(newChecked);\r\n  };\r\n\r\n  const numberOfChecked = items => intersection(checked, items).length;\r\n\r\n  const handleToggleAll = items => () => {\r\n    if (numberOfChecked(items) === items.length) {\r\n      setChecked(not(checked, items));\r\n    } else {\r\n      setChecked(union(checked, items));\r\n    }\r\n  };\r\n\r\n  const handleCheckedRight = () => {\r\n    setRight(right.concat(leftChecked));\r\n    setLeft(not(left, leftChecked));\r\n    setChecked(not(checked, leftChecked));\r\n  };\r\n\r\n  const handleCheckedLeft = () => {\r\n    setLeft(left.concat(rightChecked));\r\n    setRight(not(right, rightChecked));\r\n    setChecked(not(checked, rightChecked));\r\n  };\r\n\r\n  // Add users to left item list ComponentDidMount\r\n  useEffect(() => {\r\n    console.log('Add users left');\r\n    let users = [...props.users];\r\n    let indexes = [];\r\n\r\n    console.log(users);\r\n    console.log(props.users);\r\n    console.log(props.activeChatRoom.members);\r\n\r\n    // If a user is already member of the chatroom, splice the user from the selectable userlist\r\n    for (let i = 0; i < users.length; i++) {\r\n      //   console.log(users[i]._id);\r\n      for (let j = 0; j < props.activeChatRoom.members.length; j++) {\r\n        if (users[i]._id === props.activeChatRoom.members[j]._id) {\r\n          // console.log(users[i]);\r\n          console.log(props.activeChatRoom.members[j]);\r\n\r\n          console.log(users.indexOf(users[i]));\r\n          indexes.push(users.indexOf(users[i]));\r\n\r\n          // splice at the index where the id's match\r\n          // console.log(users.splice(users.indexOf(users[i]), 1));\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(indexes);\r\n\r\n    // Remove indexes\r\n    function spliceUserIndexes(arr) {\r\n      let remove = indexes;\r\n      for (let i = remove.length - 1; i >= 0; i--) {\r\n        arr.splice(remove[i], 1);\r\n      }\r\n    }\r\n\r\n    spliceUserIndexes(users);\r\n    setLeft(users);\r\n    console.log(users);\r\n  }, [open]);\r\n\r\n  //   Enable the submit button when 2 or more users are selected, + add current user\r\n  const handleSubmit = (e, selectedUsers) => {\r\n    e.preventDefault();\r\n    // console.log(groupName);\r\n    let socketIds = [];\r\n    let selectedUsersMinusMembers = [...selectedUsers];\r\n    selectedUsers = [...props.activeChatRoom.members, ...selectedUsers];\r\n\r\n    // geselecteerde users zonder hudige members\r\n    console.log(selectedUsersMinusMembers);\r\n\r\n    // online users's objects containing their socket ids so we can add them to the socket.room on the server side\r\n    console.log(props.usersWithSockets);\r\n\r\n    props.usersWithSockets.map((user, i) => {\r\n      // console.log(user.user._id);\r\n      selectedUsersMinusMembers.findIndex((selUser, j) => {\r\n        // console.log(selUser);\r\n        if (user.user._id === selUser._id) {\r\n          console.log(user.user);\r\n          socketIds.push(user.user.socketId);\r\n        }\r\n      });\r\n    });\r\n\r\n    console.log('socketIds of online users added to the chatroom. add to socket.room on server');\r\n    console.log(socketIds);\r\n\r\n    // geselecteerde members inclusief huidige members\r\n    // console.log(selectedUsers);\r\n\r\n    // Huidige members already present in room\r\n    // console.log(props.activeChatRoom.members);\r\n\r\n    if (selectedUsers.length > 10) {\r\n      alert('Groep heeft teveel leden (max 10)');\r\n      return dispatch({ type: SET_ERRORS, payload: 'Groep heeft teveel leden (max 10)' });\r\n    }\r\n\r\n    // selectedUsers.forEach(user => {\r\n    //   console.log(user._id);\r\n    // });\r\n\r\n    props.updateChatRoom(\r\n      socket,\r\n      props.activeChatRoom._id,\r\n      socketIds,\r\n      selectedUsers.map(user => user._id),\r\n    );\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (socket._callbacks !== undefined && socket._callbacks['$ADDED_USERS_TO_CHATROOM']) {\r\n      socket._callbacks['$ADDED_USERS_TO_CHATROOM'].length = 0;\r\n    }\r\n\r\n    socket.on(ADDED_USERS_TO_CHATROOM, data => {\r\n      console.log('ADDED_USERS_TO_CHATROOM');\r\n      console.log(data);\r\n      handleClose();\r\n      dispatch({ type: ADDED_USERS_TO_CHATROOM, payload: { data } });\r\n    });\r\n  }, [props.chatRooms]);\r\n\r\n  const customList = (title, items) => {\r\n    return (\r\n      <Card>\r\n        <CardHeader\r\n          className={classes.cardHeader}\r\n          avatar={\r\n            <Checkbox\r\n              onClick={handleToggleAll(items)}\r\n              checked={numberOfChecked(items) === items.length && items.length !== 0}\r\n              indeterminate={\r\n                numberOfChecked(items) !== items.length && numberOfChecked(items) !== 0\r\n              }\r\n              disabled={items.length === 0}\r\n              inputProps={{ 'aria-label': 'all items selected' }}\r\n            />\r\n          }\r\n          title={title}\r\n          subheader={`${numberOfChecked(items)}/${items.length} geselecteerd`}\r\n        />\r\n        <Divider />\r\n        <List className={classes.list} dense component='div' role='list'>\r\n          {items.map(value => {\r\n            const labelId = `transfer-list-all-item-${value}-label`;\r\n\r\n            return (\r\n              <ListItem key={value._id} role='listitem' button onClick={handleToggle(value)}>\r\n                <ListItemIcon>\r\n                  <Avatar src={value.avatar}></Avatar>\r\n                </ListItemIcon>\r\n                <ListItemText id={labelId} primary={firstCharUpperCase(value.username)} />\r\n                <Checkbox\r\n                  checked={checked.indexOf(value) !== -1}\r\n                  tabIndex={-1}\r\n                  disableRipple\r\n                  inputProps={{ 'aria-labelledby': labelId }}\r\n                />\r\n              </ListItem>\r\n            );\r\n          })}\r\n          <ListItem />\r\n        </List>\r\n      </Card>\r\n    );\r\n  };\r\n\r\n  const modalBody = (\r\n    <>\r\n      <Grid container spacing={2} justify='center' alignItems='center' className={classes.root}>\r\n        <Grid item>\r\n          {customList(`Groep heeft ${props.activeChatRoom.members.length} leden (max 10)`, left)}\r\n        </Grid>\r\n        <Grid item>\r\n          <Grid container direction='column' alignItems='center'>\r\n            <Button\r\n              variant='outlined'\r\n              size='small'\r\n              className={classes.button}\r\n              onClick={handleCheckedRight}\r\n              disabled={leftChecked.length === 0}\r\n              aria-label='move selected right'>\r\n              &gt;\r\n            </Button>\r\n            <Button\r\n              variant='outlined'\r\n              size='small'\r\n              className={classes.button}\r\n              onClick={handleCheckedLeft}\r\n              disabled={rightChecked.length === 0}\r\n              aria-label='move selected left'>\r\n              &lt;\r\n            </Button>\r\n          </Grid>\r\n        </Grid>\r\n        <Grid item>\r\n          {customList(\r\n            `selecteer maximaal ${10 - props.activeChatRoom.members.length} leden`,\r\n            right,\r\n          )}\r\n        </Grid>\r\n      </Grid>\r\n\r\n      {/* Form */}\r\n      <form\r\n        onSubmit={e => {\r\n          console.log('submit add users to group');\r\n          handleSubmit(e, right);\r\n        }}\r\n        className={classes.input}\r\n        noValidate\r\n        autoComplete='off'>\r\n        {/* <TextField\r\n          value={groupName}\r\n          onChange={e => {\r\n            dispatch({ type: CLEAR_ERRORS });\r\n            setGroupName(e.target.value);\r\n          }}\r\n          id='standard-basic'\r\n          label='Groepsnaam'\r\n          error={props.errors && props.errors.length > 0 ? true : false}\r\n          helperText={\r\n            props.errors && props.errors.length > 0 ? props.errors[props.errors.length - 1] : ''\r\n          }\r\n        /> */}\r\n        <Button\r\n          disabled={right.length >= 1 ? false : true}\r\n          onClick={e => {\r\n            console.log('submit add users to group');\r\n            handleSubmit(e, right);\r\n          }}\r\n          variant='contained'\r\n          color='primary'>\r\n          toevoegen\r\n        </Button>\r\n      </form>\r\n    </>\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <MenuItem\r\n        onClick={handleOpen}\r\n        disabled={props.activeChatRoom.moderator !== props.user._id ? true : false}>\r\n        Gebruiker(s) toevoegen\r\n      </MenuItem>\r\n\r\n      <div>\r\n        <Modal\r\n          className={classes.modal}\r\n          open={open}\r\n          onClose={handleClose}\r\n          aria-labelledby='simple-modal-title'\r\n          aria-describedby='simple-modal-description'>\r\n          {modalBody}\r\n        </Modal>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    socket: state.socket.socket,\r\n    user: state.user.user,\r\n    users: state.user.users,\r\n    usersWithSockets: state.user.usersWithSockets,\r\n    activeChatRoom: state.chat.activeChatRoom,\r\n    errors: state.user.errors,\r\n    theme: state.theme.theme,\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, { updateChatRoom })(JoinChatRoomModal);\r\n",{"ruleId":"164","replacedBy":"165"},{"ruleId":"166","replacedBy":"167"},{"ruleId":"168","severity":1,"message":"169","line":87,"column":6,"nodeType":"170","endLine":87,"endColumn":66,"suggestions":"171"},{"ruleId":"168","severity":1,"message":"172","line":59,"column":6,"nodeType":"170","endLine":59,"endColumn":55,"suggestions":"173"},{"ruleId":"174","severity":1,"message":"175","line":209,"column":29,"nodeType":"176","messageId":"177","endLine":209,"endColumn":31},{"ruleId":"174","severity":1,"message":"175","line":237,"column":29,"nodeType":"176","messageId":"177","endLine":237,"endColumn":31},{"ruleId":"168","severity":1,"message":"178","line":66,"column":6,"nodeType":"170","endLine":66,"endColumn":8,"suggestions":"179"},{"ruleId":"168","severity":1,"message":"178","line":70,"column":6,"nodeType":"170","endLine":70,"endColumn":26,"suggestions":"180"},{"ruleId":"181","severity":1,"message":"182","line":108,"column":13,"nodeType":"183","messageId":"184","endLine":108,"endColumn":21},{"ruleId":"181","severity":1,"message":"185","line":150,"column":7,"nodeType":"183","messageId":"184","endLine":150,"endColumn":26},{"ruleId":"181","severity":1,"message":"186","line":151,"column":7,"nodeType":"183","messageId":"184","endLine":151,"endColumn":21},{"ruleId":"174","severity":1,"message":"175","line":199,"column":28,"nodeType":"176","messageId":"177","endLine":199,"endColumn":30},{"ruleId":"174","severity":1,"message":"175","line":201,"column":35,"nodeType":"176","messageId":"177","endLine":201,"endColumn":37},{"ruleId":"174","severity":1,"message":"175","line":202,"column":46,"nodeType":"176","messageId":"177","endLine":202,"endColumn":48},{"ruleId":"181","severity":1,"message":"182","line":307,"column":31,"nodeType":"183","messageId":"184","endLine":307,"endColumn":39},{"ruleId":"181","severity":1,"message":"182","line":353,"column":31,"nodeType":"183","messageId":"184","endLine":353,"endColumn":39},{"ruleId":"181","severity":1,"message":"187","line":69,"column":5,"nodeType":"183","messageId":"184","endLine":69,"endColumn":25},{"ruleId":"181","severity":1,"message":"182","line":133,"column":13,"nodeType":"183","messageId":"184","endLine":133,"endColumn":21},{"ruleId":"168","severity":1,"message":"188","line":156,"column":6,"nodeType":"170","endLine":163,"endColumn":4,"suggestions":"189"},{"ruleId":"174","severity":1,"message":"175","line":159,"column":40,"nodeType":"176","messageId":"177","endLine":159,"endColumn":42},{"ruleId":"168","severity":1,"message":"190","line":43,"column":6,"nodeType":"170","endLine":43,"endColumn":23,"suggestions":"191"},{"ruleId":"181","severity":1,"message":"182","line":55,"column":13,"nodeType":"183","messageId":"184","endLine":55,"endColumn":21},{"ruleId":"181","severity":1,"message":"192","line":3,"column":10,"nodeType":"183","messageId":"184","endLine":3,"endColumn":23},{"ruleId":"168","severity":1,"message":"193","line":140,"column":6,"nodeType":"170","endLine":140,"endColumn":12,"suggestions":"194"},{"ruleId":"168","severity":1,"message":"195","line":172,"column":6,"nodeType":"170","endLine":172,"endColumn":12,"suggestions":"196"},{"ruleId":"174","severity":1,"message":"175","line":188,"column":42,"nodeType":"176","messageId":"177","endLine":188,"endColumn":44},{"ruleId":"174","severity":1,"message":"197","line":190,"column":56,"nodeType":"176","messageId":"177","endLine":190,"endColumn":58},{"ruleId":"168","severity":1,"message":"190","line":236,"column":6,"nodeType":"170","endLine":236,"endColumn":23,"suggestions":"198"},"no-native-reassign",["199"],"no-negated-in-lhs",["200"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.","ArrayExpression",["201"],"React Hook useEffect has a missing dependency: 'skip'. Either include it or remove the dependency array.",["202"],"array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["203"],["204"],"no-unused-vars","'memberId' is assigned a value but never used.","Identifier","unusedVar","'totalUnreadMessages' is assigned a value but never used.","'unreadMessages' is assigned a value but never used.","'getAllUnreadMessages' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'dispatch', 'getAllUserChatRooms', 'markMessagesRead', 'props.activeChatRoom._id', 'props.activeChatRoom.members', and 'user._id'. Either include them or remove the dependency array.",["205"],"React Hook useEffect has missing dependencies: 'dispatch' and 'socket'. Either include them or remove the dependency array.",["206"],"'hasDuplicates' is defined but never used.","React Hook useEffect has missing dependencies: 'props.user._id' and 'props.users'. Either include them or remove the dependency array.",["207"],"React Hook useEffect has missing dependencies: 'props.activeChatRoom.members' and 'props.users'. Either include them or remove the dependency array.",["208"],"Array.prototype.findIndex() expects a return value from arrow function.",["209"],"no-global-assign","no-unsafe-negation",{"desc":"210","fix":"211"},{"desc":"212","fix":"213"},{"desc":"214","fix":"215"},{"desc":"216","fix":"217"},{"desc":"218","fix":"219"},{"desc":"220","fix":"221"},{"desc":"222","fix":"223"},{"desc":"224","fix":"225"},{"desc":"220","fix":"226"},"Update the dependencies array to be: [updateConnectedUserList, socket, user, getAllUserChatRooms, dispatch]",{"range":"227","text":"228"},"Update the dependencies array to be: [props.activeChatRoom, props.chatMessages.length, skip]",{"range":"229","text":"230"},"Update the dependencies array to be: [props]",{"range":"231","text":"232"},"Update the dependencies array to be: [props, props.lastMessages]",{"range":"233","text":"234"},"Update the dependencies array to be: [props.chatMessages.length, socket, activeChatRoom, emitCreateChatMessageFromServerToAllClients, emitLastChatMessage, emitDeleteChatMessageFromServerToAllClients, getAllUserChatRooms, user._id, dispatch, props.activeChatRoom._id, props.activeChatRoom.members, markMessagesRead]",{"range":"235","text":"236"},"Update the dependencies array to be: [dispatch, props.chatRooms, socket]",{"range":"237","text":"238"},"Update the dependencies array to be: [open, props.user._id, props.users]",{"range":"239","text":"240"},"Update the dependencies array to be: [open, props.activeChatRoom.members, props.users]",{"range":"241","text":"242"},{"range":"243","text":"238"},[3038,3098],"[updateConnectedUserList, socket, user, getAllUserChatRooms, dispatch]",[1584,1633],"[props.activeChatRoom, props.chatMessages.length, skip]",[2414,2416],"[props]",[2497,2517],"[props, props.lastMessages]",[5631,5829],"[props.chatMessages.length, socket, activeChatRoom, emitCreateChatMessageFromServerToAllClients, emitLastChatMessage, emitDeleteChatMessageFromServerToAllClients, getAllUserChatRooms, user._id, dispatch, props.activeChatRoom._id, props.activeChatRoom.members, markMessagesRead]",[1283,1300],"[dispatch, props.chatRooms, socket]",[3832,3838],"[open, props.user._id, props.users]",[4700,4706],"[open, props.activeChatRoom.members, props.users]",[6833,6850]]